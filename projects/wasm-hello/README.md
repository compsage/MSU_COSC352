# WebAssembly Interactive Greeting (Rust)

## Overview

This project builds a WebAssembly module using Rust to generate a greeting message based on user input: name, age, and a repetition count. It returns the message repeated N times and displays it in the browser using JavaScript and HTML.

## Data Path: HTML → JS → WASM → JS → DOM

1. HTML presents input fields and a Submit button.
2. JavaScript reads values (name, age, repeat count) from the DOM.
3. JS calls the `greet` function defined in Rust (compiled to WASM via `wasm-pack`).
4. Rust/WASM returns a string with the formatted greeting repeated N times.
5. JavaScript receives the result and updates the DOM to display the full message.

## Memory Handling in WASM (Rust)

String memory is managed safely by Rust using its native `String` type. The `wasm-bindgen` library handles all marshaling between JS and WASM:

- Converts JavaScript strings into Rust `&str` parameters.
- Converts the Rust `String` result into a format JavaScript can read.
- Automatically manages memory, so no manual `malloc`/`free` calls are needed.

This setup prevents memory leaks and keeps the code simple and safe.

## Performance Considerations

- The base greeting message is created once using `format!()`.
- A `String` is pre-allocated using `String::with_capacity(...)` to reduce memory reallocations.
- The message is repeated using `push_str()` in a loop, which is more efficient than repeatedly concatenating with `+` or `+=`.
- All repetition is done inside the WASM module, avoiding performance costs from repeatedly crossing the JS-WASM boundary.

## JS vs. WASM for the Loop — Why Inside WASM?

| Option       | Pros                             | Cons                           |
|--------------|----------------------------------|--------------------------------|
| Loop in JS   | Easier to debug                  | Requires many calls to WASM    |
| Loop in WASM | Faster, fewer boundary crossings | Slightly harder to debug       |

The loop was implemented in WASM to maximize performance, reduce interop overhead, and encapsulate the logic where it belongs.

## Build Instructions

### Option 1: Run the Precompiled Version (No Setup Needed)

1. Make sure the `pkg/` folder is included.
2. Run a local server from the project directory:
   ```
   python -m http.server
   ```
3. Open your browser and go to:
   ```
   http://localhost:8000
   ```

### Option 2: Build from Source (Optional for Developers)

If you want to compile the WASM module yourself:

1. Install Rust: https://rustup.rs  
2. Add the WASM target:
   ```
   rustup target add wasm32-unknown-unknown
   ```
3. Install wasm-pack:
   ```
   cargo install wasm-pack
   ```
4. Build the WebAssembly package:
   ```
   wasm-pack build --target web
   ```

## Files

```text
wasm-hello/
├── index.html             # User interface
├── main.js                # JavaScript logic and WASM integration
├── Cargo.toml             # Rust project configuration
├── src/
│   └── lib.rs             # Rust source code (contains the greet function)
├── pkg/                   # WebAssembly output (generated by wasm-pack build)
│   ├── wasm_hello.js          # JavaScript glue code
│   ├── wasm_hello_bg.wasm     # Compiled WebAssembly module
│   ├── package.json           # Metadata for the WASM package
```

## Example Output

If the user inputs:
- Name: Kait  
- Age: 19  
- Repetitions: 3  

The output will be:

```
Hello, Kait. You are 19 years old.
Hello, Kait. You are 19 years old.
Hello, Kait. You are 19 years old.
```
